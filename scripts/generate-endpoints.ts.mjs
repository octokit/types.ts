// @ts-check
import { readFileSync, stat, writeFileSync } from "node:fs";
import { resolve } from "node:path";

import { format } from "prettier";

/** @typedef {import('openapi-types').OpenAPIV3.Document} OpenAPIV3Document */
/** @typedef {import('openapi-types').OpenAPIV3.ReferenceObject} OpenAPIV3ReferenceObject */
/** @typedef {import('openapi-types').OpenAPIV3.SchemaObject} OpenAPIV3SchemaObject */
/** @typedef {import('openapi-types').OpenAPIV3.ParameterObject} OpenAPIV3ParameterObject */
/** @typedef {import('openapi-types').OpenAPIV3.HeaderObject} OpenAPIV3HeaderObject */
/** @typedef {import('openapi-types').OpenAPIV3.ResponseObject} OpenAPIV3ResponseObject */
/** @typedef {import('openapi-types').OpenAPIV3.ResponsesObject} OpenAPIV3ResponsesObject */

const knownResponseTypes = /** @type {const} */ ([
  "application/json",
  "application/octocat-stream",
  "application/scim+json",
  "text/html",
  "text/plain",
]);

const successStatuses = /** @type {const} */ ([200, 201, 202, 204, 205]);
const redirectStatuses = /** @type {const} */ ([301, 302]);
const emptyResponseStatuses = /** @type {const} */ ([201, 204, 205]);

/**
 * @param {string} value
 * @param {string} suffix
 * @returns {string}
 */
function toTypeName(value, suffix = "") {
  return (value + "-" + suffix).replace(/(^\w|-\w|_\w)/g, clearAndUpper);
}

/**
 * @param {string} text
 * @returns {string}
 */
function clearAndUpper(text) {
  return text.replace(/[-|_]/g, "").toUpperCase();
}

/** @type {Required<OpenAPIV3Document>} */
const openApiSpec = JSON.parse(
  readFileSync(
    new URL("../cache/api.github.com.json", import.meta.url),
    "utf8",
  ),
);
let tsd = `// This file is auto-generated by scripts/generate-endpoints.ts.mjs\n\n
import type { RequestHeaders } from "../RequestHeaders.js";
import type { RequestRequestOptions } from "../RequestRequestOptions.js";
import type { ResponseHeaders } from "../ResponseHeaders.js"
`;

for (const schemaName in openApiSpec.components.schemas) {
  if (isReferenceObject(openApiSpec.components.schemas[schemaName])) {
    const result = processReferenceObject(
      schemaName,
      openApiSpec.components.schemas[schemaName],
    );
    tsd += `type ${toTypeName(schemaName, "component")} = ${result}\n\n`;
  } else {
    const result = processSchemaObject(
      schemaName,
      openApiSpec.components.schemas[schemaName],
      "schema",
    );
    tsd += result;
  }
}
for (const parameterName in openApiSpec.components.parameters) {
  if (isReferenceObject(openApiSpec.components.parameters[parameterName])) {
    const result = processReferenceObject(
      parameterName,
      openApiSpec.components.parameters[parameterName],
    );
    tsd += `type ${toTypeName(parameterName, "parameter")} = ${result}\n\n`;
  } else {
    const result = processParameterObject(
      parameterName,
      openApiSpec.components.parameters[parameterName],
    );
    tsd += result;
  }
}
for (const headerName in openApiSpec.components.headers) {
  if (isReferenceObject(openApiSpec.components.headers[headerName])) {
    const result = processReferenceObject(
      headerName,
      openApiSpec.components.headers[headerName],
    );
    tsd += `type ${toTypeName(headerName, "header")} = ${result}\n\n`;
  } else {
    const result = processHeaderObject(
      headerName,
      openApiSpec.components.headers[headerName],
    );
    tsd += result;
  }
}

for (const responseName in openApiSpec.components.responses) {
  if (isReferenceObject(openApiSpec.components.responses[responseName])) {
    const result = processReferenceObject(
      responseName,
      openApiSpec.components.responses[responseName],
    );
    tsd += `type ${toTypeName(responseName, "response")} = ${result}\n\n`;
  } else {
    const result = processResponseObject(
      responseName,
      openApiSpec.components.responses[responseName],
    );
    tsd += result;
  }
}

tsd += `export interface Endpoints {\n`;
for (const pathName in openApiSpec.paths) {
  const path = openApiSpec.paths[pathName];

  for (const method of Object.keys(path)) {
    if (isValidOpenApiMethod(method) === false) {
      continue;
    }
    /** @type {import('openapi-types').OpenAPIV3.OperationObject} */
    const operation = path[method];

    if (!operation) {
      continue;
    }

    const upperCaseMethod = method.toUpperCase();
    // if (upperCaseMethod !== "POST" || pathName !== "/user/repos") {
    //   continue
    // }
    const result = [];

    const {
      summary,
      description,
      parameters,
      requestBody,
      responses,
      callbacks,
      security,
      servers,
      externalDocs,
      operationId,
      deprecated,
    } = operation;

    const jsdoc = [];

    if (operationId) {
      jsdoc.push(` * @name ${operationId}\n`);
    }

    if (summary) {
      jsdoc.push(
        ` * @summary ${summary
          .split("\n")
          .map((v, i) => (i === 0 ? v : ` * ${v}`))
          .join("\n")}\n`,
      );
    }
    if (description) {
      jsdoc.push(
        ` * @description ${description
          .replace("*/", "*\\/")
          .split("\n")
          .map((v, i) => (i === 0 ? v : ` * ${v}`))
          .join("\n")}\n`,
      );
    }

    if (deprecated) {
      jsdoc.push(` * @deprecated\n`);
    }
    if (externalDocs && externalDocs.url) {
      jsdoc.push(` * @see ${externalDocs.url}\n`);
    }

    if (jsdoc.length) {
      result.push(`/**\n`);
      result.push(...jsdoc);
      result.push(` */\n`);
    }
    result.push(` "${upperCaseMethod} ${pathName}": {\n`);
    result.push(`  parameters: {\n`);
    if (Array.isArray(parameters) && parameters.length !== 0) {
      for (const param of parameters) {
        if (isReferenceObject(param)) {
          // Referenzierte Parameter: Hole den Namen aus der Ref
          const refName = param.$ref.split("/").pop();
          const originalParam = openApiSpec.components.parameters[refName];
          if (originalParam && !isReferenceObject(originalParam)) {
            const isOptional = originalParam.required ? "" : "?";
            const sanitizedName = needsQuotes(originalParam.name)
              ? JSON.stringify(originalParam.name)
              : originalParam.name;
            result.push(
              `    ${sanitizedName}${isOptional}: ${processType(originalParam.name, originalParam.schema, true)};\n`,
            );
          }
        } else {
          // Inline Parameter
          const isOptional = param.required ? "" : "?";
          const sanitizedName = needsQuotes(param.name)
            ? JSON.stringify(param.name)
            : param.name;
          const jsdoc = [];

          if (param.description) {
            jsdoc.push(
              ` * @description ${param.description
                .replace("*/", "*\\/")
                .split("\n")
                .map((v, i) => (i === 0 ? v : ` * ${v}`))
                .join("\n")}\n`,
            );
          }
          if (param.deprecated) {
            jsdoc.push(` * @deprecated\n`);
          }
          if (param.example) {
            const exampleText =
              typeof param.example === "string"
                ? param.example
                    .replace("*/", "*\\/")
                    .split("\n")
                    .map((v, i) => (i === 0 ? v : ` * ${v}`))
                    .join("\n")
                : JSON.stringify(param.example, null, 2);
            jsdoc.push(` * @example ${exampleText}\n`);
          }
          if (param.deprecated) {
            jsdoc.push(` * @deprecated\n`);
          }

          if (jsdoc.length) {
            result.push(`    /**\n`);
            result.push(...jsdoc);
            result.push(`     */\n`);
          }
          result.push(
            `    ${sanitizedName}${isOptional}: ${processType(param.name, param.schema, true)};\n`,
          );
        }
      }
    }

    result.push(`  }\n`);

    if (requestBody) {
      for (const contentType in requestBody.content) {
        if (!knownResponseTypes.includes(contentType)) {
          continue;
        }
        result.push(
          `& Endpoints['${upperCaseMethod} ${pathName}']['request']['data']\n`,
        );
        break;
      }
    }

    result.push(`  request: {\n`);
    result.push(`        method: "${upperCaseMethod}"\n`);
    result.push(`        url: '${pathName}'\n`);
    result.push(`        headers: RequestHeaders\n`);
    result.push(`        request: RequestRequestOptions\n`);

    if (requestBody) {
      if (isReferenceObject(requestBody)) {
        const refType = processReferenceObject("RequestBody", requestBody);
        result.push(`  data: ${refType}\n`);
      } else {
        for (const contentType in requestBody.content) {
          if (!knownResponseTypes.includes(contentType)) {
            continue;
          }
          result.push(
            `  data: ${processType("data", requestBody.content[contentType].schema, true)}\n`,
          );
          break;
        }
      }
    }

    result.push(`      }\n`);

    const response = processResponsesObject(responses);

    result.push(`  response: ${response}\n`);
    result.push(`  }\n`);
    tsd += result.join("");
  }
}
tsd += `}\n`;

tsd += `\nexport type EndpointKeys = keyof Endpoints;\n`;

const ENDPOINTS_PATH = resolve(
  process.cwd(),
  "src",
  "generated",
  "Endpoints.ts",
);

// writeFileSync(ENDPOINTS_PATH, tsd);
writeFileSync(ENDPOINTS_PATH, await format(tsd, { parser: "typescript" }));
console.log(`${ENDPOINTS_PATH} updated.`);

/**
 * @param {OpenAPIV3ReferenceObject|OpenAPIV3SchemaObject|OpenAPIV3ParameterObject|OpenAPIV3HeaderObject} schema
 * @returns {schema is OpenAPIV3ReferenceObject}
 */
function isReferenceObject(schema) {
  return schema && typeof schema === "object" && "$ref" in schema;
}

/**
 * @param {string} schemaName
 * @param {OpenAPIV3ReferenceObject} schema
 * @returns {string}
 */
function processReferenceObject(schemaName, schema) {
  if (!schema.$ref) {
    throw new Error(`Expected $ref in schema: ${schemaName}`);
  }
  const ref = schema.$ref.split("/");
  const refType = ref.pop();
  if (!refType) {
    throw new Error(`Invalid $ref: ${schema.$ref} for ${schemaName}`);
  }
  const type = ref.pop()?.slice(0, -1);

  return toTypeName(refType, type);
}

/**
 * @param {string} schemaName
 * @param {OpenAPIV3SchemaObject} schema
 * @param {'parameter'|'schema'} type
 * @returns {string}
 */
function processSchemaObject(schemaName, schema, type) {
  const name = toTypeName(schemaName, type);

  return processType(name, schema, false, type);
}

/**
 * @param {string} parameterName
 * @param {OpenAPIV3ParameterObject} parameter
 * @returns
 */
function processParameterObject(parameterName, parameter) {
  const name = toTypeName(parameterName, "parameter");

  if (isReferenceObject(parameter)) {
    const refType = processReferenceObject(name, parameter);
    return `type ${name} = ${refType}\n\n`;
  } else if (typeof parameter === "object") {
    if (parameter.schema) {
      if (isReferenceObject(parameter.schema)) {
        const refType = processReferenceObject(name, parameter.schema);
        return `type ${name} = ${refType}\n\n`;
      } else if (typeof parameter.schema === "object") {
        const jsdoc = [];
        if (parameter.description) {
          jsdoc.push(
            ` * @description ${parameter.description
              .replace("*/", "*\\/")
              .split("\n")
              .map((v, i) => (i === 0 ? v : ` * ${v}`))
              .join("\n")}\n`,
          );
        }
        if (parameter.deprecated) {
          jsdoc.push(` * @deprecated\n`);
        }
        if (parameter.example) {
          const exampleText =
            typeof parameter.example === "string"
              ? parameter.example
                  .replace("*/", "*\\/")
                  .split("\n")
                  .map((v, i) => (i === 0 ? v : ` * ${v}`))
                  .join("\n")
              : JSON.stringify(parameter.example, null, 2);
          jsdoc.push(` * @example ${exampleText}\n`);
        }
        if (parameter.schema.default) {
          jsdoc.push(
            ` * @default ${JSON.stringify(parameter.schema.default)}\n`,
          );
        }
        if (parameter.schema.readOnly) {
          jsdoc.push(` * @readonly\n`);
        }

        const result = [];

        if (jsdoc.length) {
          result.push(`/**\n`);
          result.push(...jsdoc);
          result.push(` */\n`);
        }

        result.push(
          `type ${name} = { ${parameter.name}: ${processType(name, parameter.schema, true, "parameter")} }\n\n`,
        );

        return result.join("");
      } else {
        return `type ${name} = any\n\n`;
      }
    } else {
      return `type ${name} = any\n\n`;
    }
  } else {
    return `type ${name} = any\n\n`;
  }
}

/**
 * @param {string} headerName
 * @param {OpenAPIV3ReferenceObject|OpenAPIV3HeaderObject} header
 * @return {string}
 */
function processHeaderObject(headerName, header, onlyType = false) {
  const name = toTypeName(headerName, "header");

  if (isReferenceObject(header)) {
    const refType = processReferenceObject(headerName, header);
    return `type ${name} = ${refType}\n\n`;
  } else if (typeof header === "object") {
    if (header.schema) {
      if (isReferenceObject(header.schema)) {
        const refType = processReferenceObject(name, header.schema);
        return `type ${name} = ${refType}\n\n`;
      } else if (typeof header.schema === "object") {
        const jsdoc = [];
        if (header.description) {
          jsdoc.push(
            ` * @description ${header.description
              .replace("*/", "*\\/")
              .split("\n")
              .map((v, i) => (i === 0 ? v : ` * ${v}`))
              .join("\n")}\n`,
          );
        }
        if (header.deprecated) {
          jsdoc.push(` * @deprecated\n`);
        }
        if (header.example) {
          const exampleText =
            typeof header.example === "string"
              ? header.example
                  .replace("*/", "*\\/")
                  .split("\n")
                  .map((v, i) => (i === 0 ? v : ` * ${v}`))
                  .join("\n")
              : JSON.stringify(header.example, null, 2);
          jsdoc.push(` * @example ${exampleText}\n`);
        }
        if (header.schema.default) {
          jsdoc.push(` * @default ${JSON.stringify(header.schema.default)}\n`);
        }
        if (header.schema.readOnly) {
          jsdoc.push(` * @readonly\n`);
        }

        const result = [];

        if (jsdoc.length) {
          result.push(`/**\n`);
          result.push(...jsdoc);
          result.push(` */\n`);
        }

        result.push(
          `type ${name} = ${processType(name, header.schema, true, "header")}\n\n`,
        );

        return result.join("");
      } else {
        return `type ${name} = any\n\n`;
      }
    } else {
      return `type ${name} = any\n\n`;
    }
  } else {
    return `type ${name} = any\n\n`;
  }
}

/**
 * @param {string} name
 * @param {OpenAPIV3SchemaObject} schema
 * @param {boolean} [onlyType=false]
 * @param {'parameter'|'schema'|'header'|'response'} [type]
 * @return {string}
 */
function processType(name, schema, onlyType = false, type) {
  const result = [];
  const jsdoc = [];

  if (onlyType === false) {
    if (schema.description) {
      const description = schema.description
        .replace("*/", "*\\/")
        .split("\n")
        .map((v, i) => (i === 0 ? v : ` * ${v}`))
        .join("\n");
      jsdoc.push(` * @description ${description}\n`);
    }
    if (schema.deprecated) {
      result.push(` * @deprecated\n`);
    }
    if (schema.example) {
      const example =
        typeof schema.example === "string"
          ? schema.example
              .replace("*/", "*\\/")
              .split("\n")
              .map((v, i) => (i === 0 ? v : ` * ${v}`))
              .join("\n")
          : JSON.stringify(schema.example, null, 2);
      jsdoc.push(` * @example ${example}\n`);
    }
    if (typeof schema.externalDocs === "object" && schema.externalDocs.url) {
      jsdoc.push(` * @see ${schema.externalDocs.url}\n`);
    }
    if (typeof schema.default !== "undefined") {
      jsdoc.push(` * @default ${JSON.stringify(schema.default)}\n`);
    }
    if (schema.readOnly) {
      jsdoc.push(` * @readonly\n`);
    }
  }

  if (schema.oneOf || schema.anyOf || schema.allOf) {
    const schemaType = schema.oneOf
      ? "oneOf"
      : schema.anyOf
        ? "anyOf"
        : "allOf";
    const types = schema[schemaType].map((subSchema, index) => {
      if (isReferenceObject(subSchema)) {
        return processReferenceObject(name, subSchema);
      } else if (subSchema) {
        return processType(name, subSchema, true, type);
      } else {
        return "any";
      }
    });
    switch (schemaType) {
      case "oneOf":
      case "anyOf": {
        result.push("(");
        result.push(types.join(" | "));
        result.push(")");
        if (schema.nullable) {
          result.push(" | null");
        }
        break;
      }
      case "allOf": {
        result.push("(");
        result.push(types.join(" & "));
        result.push(")");
        if (schema.nullable) {
          result.push(" | null");
        }
        break;
      }
    }
  } else {
    switch (schema.type) {
      case "boolean": {
        if (schema.readOnly) {
          result.push("Readonly<");
        }
        result.push("boolean");
        if (schema.nullable) {
          result.push(" | null");
        }
        if (schema.readOnly) {
          result.push(">");
        }
        break;
      }
      case "array": {
        if (schema.readOnly) {
          result.push("Readonly<");
        }
        if (!schema.items) {
          result.push("any[]");
        } else if (isReferenceObject(schema.items)) {
          result.push(`Array<${processReferenceObject(name, schema.items)}>`); // ✅ Array<> hinzugefügt
        } else {
          result.push(
            `Array<${processType(name + "Item", schema.items, true, type)}>`,
          );
        }
        if (schema.nullable) {
          result.push(" | null");
        }
        if (schema.readOnly) {
          result.push(">");
        }
        break;
      }
      case "number":
      case "integer": {
        if (schema.readOnly) {
          result.push("Readonly<");
        }
        result.push("number");
        if (schema.nullable) {
          result.push(" | null");
        }
        if (schema.readOnly) {
          result.push(">");
        }
        break;
      }
      case "string": {
        if (schema.readOnly) {
          result.push("Readonly<");
        }
        if (schema.enum) {
          result.push(
            schema.enum.map((value) => JSON.stringify(value)).join(" | "),
          );
        } else {
          result.push("string");
        }
        if (schema.nullable) {
          result.push(" | null");
        }
        if (schema.readOnly) {
          result.push(">");
        }
        break;
      }
      case undefined:
      case "object": {
        result.push("{\n");

        if (schema.properties) {
          const required =
            (Array.isArray(schema.required) && schema.required) || [];
          for (const propName in schema.properties) {
            const propSchema = schema.properties[propName];
            const isOptional = required.includes(propName) ? "" : "?";
            const sanitizedName = needsQuotes(propName)
              ? JSON.stringify(propName)
              : propName;

            if (isReferenceObject(propSchema)) {
              const refType = processReferenceObject(name, propSchema);
              result.push(`  ${sanitizedName}${isOptional}: ${refType}\n`);
            } else if (typeof propSchema === "object") {
              const jsdoc = [];
              if (propSchema.description) {
                const description = propSchema.description
                  .replace("*/", "*\\/")
                  .split("\n")
                  .map((v, i) => (i === 0 ? v : ` * ${v}`))
                  .join("\n");
                jsdoc.push(` * @description ${description}\n`);
              }
              if (propSchema.deprecated) {
                jsdoc.push(` * @deprecated\n`);
              }
              if (propSchema.example) {
                const example =
                  typeof propSchema.example === "string"
                    ? propSchema.example
                        .replace("*/", "*\\/")
                        .split("\n")
                        .map((v, i) => (i === 0 ? v : ` * ${v}`))
                        .join("\n")
                    : JSON.stringify(propSchema.example, null, 2);
                jsdoc.push(` * @example ${example}\n`);
              }
              if (
                typeof propSchema.externalDocs === "object" &&
                propSchema.externalDocs.url
              ) {
                jsdoc.push(` * @see ${propSchema.externalDocs.url}\n`);
              }
              if (typeof propSchema.default !== "undefined") {
                jsdoc.push(
                  ` * @default ${JSON.stringify(propSchema.default)}\n`,
                );
              }
              if (propSchema.readOnly) {
                jsdoc.push(` * @readonly\n`);
              }
              let propType = processType(
                name + toTypeName(sanitizedName, "component"),
                propSchema,
                true,
                type,
              );
              if (jsdoc.length) {
                result.push(`  /**\n`);
                result.push(...jsdoc);
                result.push(`  */\n`);
              }

              if (propSchema.readOnly) {
                result.push(
                  `  readonly ${sanitizedName}${isOptional}: ${propType}\n`,
                );
              } else {
                result.push(`  ${sanitizedName}${isOptional}: ${propType}\n`);
              }
            } else {
              result.push(`  ${sanitizedName}${isOptional}: any\n`);
            }
          }
        }

        if (schema.additionalProperties) {
          if (schema.additionalProperties === true) {
            result.push(`[key: string]: any\n`);
          } else if (isReferenceObject(schema.additionalProperties)) {
            const refType = processReferenceObject(
              name,
              schema.additionalProperties,
            );
            result.push(`[key: string]: ${refType}\n`);
          } else if (typeof schema.additionalProperties === "object") {
            const addPropType = processType(
              name + "AdditionalProperty",
              schema.additionalProperties,
              true,
              type,
            );
            result.push(`[key: string]: ${addPropType}\n`);
          } else if (schema.additionalProperties === false) {
            // do nothing
          } else {
            result.push(`[key: string]: any\n`);
          }
        }
        result.push(`}\n`);
        if (schema.nullable) {
          result.push(" | null");
        }
        break;
      }
      default: {
        if (isReferenceObject(schema)) {
          const refType = processReferenceObject(name, schema);
          result.push(refType);
        } else if (schema.enum) {
          result.push(
            schema.enum.map((value) => JSON.stringify(value)).join(" | "),
          );
        } else {
          result.push("any");
        }

        if (schema.nullable) {
          result.push(" | null");
        }
        break;
      }
    }
  }

  if (onlyType) {
    return result.join("");
  } else {
    result.unshift(`type ${name} = `);
    if (jsdoc.length) {
      result.unshift(` */\n`);
      result.unshift(...jsdoc);
      result.unshift(`/**\n`);
    }
    result.push(`\n`);
  }

  return result.join("");
}

/**
 * @param {string} key
 * @returns {boolean}
 */
function needsQuotes(key) {
  // Check if key is a valid JavaScript identifier
  // Valid: starts with letter/underscore/$, contains only letters/numbers/underscore/$
  return !/^[a-zA-Z_$][a-zA-Z0-9_$]*$/.test(key);
}

/**
 * @param {string} method
 * @returns {method is "get"|"put"|"post"|"delete"|"options"|"head"|"patch"|"trace"}
 */
function isValidOpenApiMethod(method) {
  return [
    "get",
    "put",
    "post",
    "delete",
    "options",
    "head",
    "patch",
    "trace",
  ].includes(method);
}

/**
 * @param {OpenAPIV3ResponsesObject} responses
 * @returns {string}
 */
function processResponsesObject(responses) {
  const statusCodes = Object.keys(responses);

  for (const statusCode of statusCodes) {
    const numericStatus = parseInt(statusCode, 10);
    if (successStatuses.includes(numericStatus)) {
      const response = responses[statusCode];
      if (isReferenceObject(response)) {
        return `{
            headers: ResponseHeaders\n
            url: string\n
            status: ${numericStatus}\n
            data: ${emptyResponseStatuses.includes(numericStatus) ? "never" : processReferenceObject("Response", response)}\n
          }`;
      } else if (typeof response === "object" && response.content) {
        const contentTypes = Object.keys(response.content).filter((ct) =>
          knownResponseTypes.includes(ct),
        );
        if (contentTypes.length === 0) {
          return `{
            headers: ResponseHeaders\n
            url: string\n
            status: ${numericStatus}\n
            data: ${emptyResponseStatuses.includes(numericStatus) ? "never" : "any"}\n\n
          }`;
        } else if (contentTypes.length === 1) {
          return `{
            headers: ResponseHeaders\n
            url: string\n
            status: ${numericStatus}\n
            data: ${emptyResponseStatuses.includes(numericStatus) ? "never" : processResponseObject("responses", response, true)}\n\n
          }`;
        }
      }
    }
  }

  for (const statusCode of statusCodes) {
    const numericStatus = parseInt(statusCode, 10);
    if (emptyResponseStatuses.includes(numericStatus)) {
      return "never";
    }
  }

  for (const statusCode of statusCodes) {
    const numericStatus = parseInt(statusCode, 10);
    if (redirectStatuses.includes(numericStatus)) {
      return "any";
    }
  }
  return "never";
}

/**
 * @param {string} responseName
 * @param {OpenAPIV3ResponseObject} response
 * @returns {string}
 */
/**
 * @param {string} responseName
 * @param {OpenAPIV3ResponseObject} response
 * @param {boolean} [onlyType=false] - If true, returns only the type without export declaration
 * @returns {string}
 */
function processResponseObject(responseName, response, onlyType = false) {
  const name = toTypeName(responseName, "response");

  if (isReferenceObject(response)) {
    const refType = processReferenceObject(responseName, response);
    return onlyType ? refType : `type ${name} = ${refType}\n\n`;
  } else if (typeof response === "object" && response.content) {
    const contentTypes = Object.keys(response.content).filter((ct) =>
      knownResponseTypes.includes(ct),
    );

    if (contentTypes.length === 0) {
      return onlyType ? "any" : `type ${name} = any\n\n`;
    } else if (contentTypes.length === 1) {
      const contentType = contentTypes[0];
      const mediaTypeObject = response.content[contentType];

      if (mediaTypeObject && mediaTypeObject.schema) {
        if (isReferenceObject(mediaTypeObject.schema)) {
          const refType = processReferenceObject(name, mediaTypeObject.schema);
          return onlyType ? refType : `type ${name} = ${refType}\n\n`;
        } else {
          const typeStr = processType(
            name,
            mediaTypeObject.schema,
            true,
            "response",
          );
          return onlyType ? typeStr : `type ${name} = ${typeStr}\n\n`;
        }
      } else {
        return onlyType ? "any" : `type ${name} = any\n\n`;
      }
    } else {
      // Multiple content types - create union
      const types = contentTypes.map((contentType) => {
        const mediaTypeObject = response.content[contentType];
        if (mediaTypeObject && mediaTypeObject.schema) {
          if (isReferenceObject(mediaTypeObject.schema)) {
            return processReferenceObject(name, mediaTypeObject.schema);
          } else if (typeof mediaTypeObject.schema === "object") {
            return processType(
              name + toTypeName(contentType, "content"),
              mediaTypeObject.schema,
              true,
              "response",
            );
          } else {
            return "any";
          }
        } else {
          return "any";
        }
      });
      const unionType = types.join(" | ");
      return onlyType ? unionType : `type ${name} = ${unionType}\n\n`;
    }
  } else {
    return onlyType ? "any" : `type ${name} = any\n\n`;
  }
}
